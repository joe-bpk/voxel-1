--- ./Cargo.toml ---
[package]
name = "rust-game"
version = "0.1.0"
edition = "2024"

[dependencies]
raylib = "5.5.1"
noiselib = "0.2.4"


--- ./src/display/mod.rs ---
use raylib::{ffi::DrawCube, prelude::*};

use crate::level::Level;

pub struct Display
{
    pub rl: RaylibHandle,
    pub thread: RaylibThread,
    cam:    Camera3D,
}

impl Display
{
    pub fn new() -> Self
    {
        let (mut rl, thread) = raylib::init().build();
        let mut cam = Camera3D::perspective(
            Vector3 {
                x: -50.0,
                y: 100.0,
                z: -50.0,
            },
            Vector3 {
                x: 0.0,
                y: 0.0,
                z: 0.0,
            },
            Vector3 {
                x: 0.0,
                y: 1.0,
                z: 0.0,
            },
            45.0,
        );
        return Self {
            rl,
            thread,
            cam,
        };
    }

    fn draw_3d(d: &mut RaylibMode3D<RaylibDrawHandle>, lvl: &Level)
    {
        lvl.terrain.draw(d);
    }

    pub fn draw_loop(&mut self, lvl: &Level)
    {
        let mut d = self.rl.begin_drawing(&self.thread);
        d.clear_background(Color::WHITE);

        {
            let mut d3d = d.begin_mode3D(self.cam);
            Self::draw_3d(&mut d3d, lvl);
        }

        // 2d drawing
        d.draw_text("Hello from Joe", 20, 20, 20, Color::BLUE);
        d.draw_fps(20, 50);
    }
}


--- ./src/level/mod.rs ---
mod terrain;
mod utils;

use terrain::Terrain;

use raylib::prelude::*;

pub struct Level
{
    pub terrain: Terrain,
}

impl Level
{
    pub fn new() -> Self
    {
        return Self {
            terrain: Terrain::new(),
        };
    }
    pub fn update(&mut self)
    {
    }
}


--- ./src/level/terrain.rs ---
use crate::level::utils::*;
use noiselib::*;
use raylib::prelude::*;

#[derive(Copy, Clone)]
struct Block
{
    block_id: usize,
    health:   i32,
}

impl Block
{
    pub fn is_solid(&self) -> bool
    {
        self.block_id != 0
    }
}

pub struct Chunk
{
    chunk_loc: ChunkLoc,
    blocks:    Box<[[[Block; CHUNKSIZE]; WORLDHEIGHT]; CHUNKSIZE]>,
}

impl Chunk
{
    pub fn new() -> Self
    {
        Self {
            chunk_loc: ChunkLoc {
                loc: IntVec3::zero(),
            },
            blocks:    Box::new(
                [[[Block {
                    health:   100,
                    block_id: 1,
                }; CHUNKSIZE]; WORLDHEIGHT]; CHUNKSIZE],
            ),
        }
    }

    pub fn perlinify(&mut self)
    {
        let mut seed = 10;
        let mut rng = noiselib::prelude::UniformRandomGen::new(seed);

        for x in 0..CHUNKSIZE {
            for y in 0..WORLDHEIGHT {
                for z in 0..CHUNKSIZE {
                    let mut perlin_out = perlin::perlin_noise_2d(
                        &mut rng,
                        (x as f32 / WORLDSIZE_BLOCKS as f32),
                        (z as f32 / WORLDSIZE_BLOCKS as f32),
                        seed,
                    );

                    let mut block_id = 1;

                    if (perlin_out + 0.5) * WORLDHEIGHT as f32 > y as f32 {
                        block_id = 1;
                    } else {
                        block_id = 0;
                    }
                    self.blocks[x][y][z].block_id = block_id;
                }
            }
        }
    }

    pub fn get_block(&self, x: i32, y: i32, z: i32) -> Option<&Block>
    {
        if x < 0 || y < 0 || z < 0
            || x >= CHUNKSIZE as i32
            || y >= WORLDHEIGHT as i32
            || z >= CHUNKSIZE as i32
        {
            return None;
        }
        Some(&self.blocks[x as usize][y as usize][z as usize])
    }
}

pub struct Terrain
{
    chunks: Box<[[Chunk; WORLDSIZE_CHUNK]; WORLDSIZE_CHUNK]>,
    mesh: Option<Mesh>,
}

impl Terrain
{
    pub fn new() -> Self
    {
        let mut chunks: Box<[[Chunk; WORLDSIZE_CHUNK]; WORLDSIZE_CHUNK]> =
            Box::new(std::array::from_fn(|_| {
                std::array::from_fn(|_| Chunk::new())
            }));

        for x in 0..WORLDSIZE_CHUNK {
            for z in 0..WORLDSIZE_CHUNK {
                chunks[x][z].chunk_loc.loc = IntVec3 {
                    x: x as i32,
                    y: 0,
                    z: z as i32,
                };
            }
        }

        return Self {
            chunks,
            mesh: None,
        };
    }

    pub fn perlinify(&mut self)
    {
        for x in 0..WORLDSIZE_CHUNK {
            for z in 0..WORLDSIZE_CHUNK {
                self.chunks[x][z].perlinify();
            }
        }
    }

    fn get_block_global(&self, x: i32, y: i32, z: i32) -> Option<&Block>
    {
        let chunk_x = x.div_euclid(CHUNKSIZE as i32);
        let chunk_z = z.div_euclid(CHUNKSIZE as i32);

        if chunk_x < 0 || chunk_z < 0
            || chunk_x >= WORLDSIZE_CHUNK as i32
            || chunk_z >= WORLDSIZE_CHUNK as i32
        {
            return None;
        }

        let local_x = x.rem_euclid(CHUNKSIZE as i32);
        let local_z = z.rem_euclid(CHUNKSIZE as i32);

        self.chunks[chunk_x as usize][chunk_z as usize].get_block(local_x, y, local_z)
    }

    pub fn build_mesh(&mut self, rl: &mut RaylibHandle, thread: &RaylibThread)
    {
        let mut vertices: Vec<f32> = Vec::new();
        let mut normals: Vec<f32> = Vec::new();
        let mut colors: Vec<u8> = Vec::new();
        let mut indices: Vec<u16> = Vec::new();

        let mut vertex_count = 0u16;

        // Define cube face vertices (relative to block position)
        let face_vertices = [
            // Front face (+Z)
            [(0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0)],
            // Back face (-Z)
            [(1.0, 0.0, 0.0), (0.0, 0.0, 0.0), (0.0, 1.0, 0.0), (1.0, 1.0, 0.0)],
            // Top face (+Y)
            [(0.0, 1.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0), (0.0, 1.0, 1.0)],
            // Bottom face (-Y)
            [(0.0, 0.0, 1.0), (1.0, 0.0, 1.0), (1.0, 0.0, 0.0), (0.0, 0.0, 0.0)],
            // Right face (+X)
            [(1.0, 0.0, 1.0), (1.0, 0.0, 0.0), (1.0, 1.0, 0.0), (1.0, 1.0, 1.0)],
            // Left face (-X)
            [(0.0, 0.0, 0.0), (0.0, 0.0, 1.0), (0.0, 1.0, 1.0), (0.0, 1.0, 0.0)],
        ];

        let face_normals = [
            (0.0, 0.0, 1.0),   // Front
            (0.0, 0.0, -1.0),  // Back
            (0.0, 1.0, 0.0),   // Top
            (0.0, -1.0, 0.0),  // Bottom
            (1.0, 0.0, 0.0),   // Right
            (-1.0, 0.0, 0.0),  // Left
        ];

        let neighbor_offsets = [
            (0, 0, 1),   // Front
            (0, 0, -1),  // Back
            (0, 1, 0),   // Top
            (0, -1, 0),  // Bottom
            (1, 0, 0),   // Right
            (-1, 0, 0),  // Left
        ];

        // Iterate through all chunks
        for chunk_x in 0..WORLDSIZE_CHUNK {
            for chunk_z in 0..WORLDSIZE_CHUNK {
                let chunk = &self.chunks[chunk_x][chunk_z];
                let chunk_world_loc = chunk.chunk_loc.toWorldLoc();

                // Iterate through all blocks in the chunk
                for x in 0..CHUNKSIZE {
                    for y in 0..WORLDHEIGHT {
                        for z in 0..CHUNKSIZE {
                            let block = &chunk.blocks[x][y][z];

                            if !block.is_solid() {
                                continue;
                            }

                            let world_x = chunk_world_loc.x + x as i32;
                            let world_y = y as i32;
                            let world_z = chunk_world_loc.z + z as i32;

                            // Check each face
                            for face_idx in 0..6 {
                                let (nx, ny, nz) = neighbor_offsets[face_idx];
                                let neighbor_x = world_x + nx;
                                let neighbor_y = world_y + ny;
                                let neighbor_z = world_z + nz;

                                // Check if neighbor is solid
                                let should_draw_face = match self.get_block_global(neighbor_x, neighbor_y, neighbor_z) {
                                    Some(neighbor) => !neighbor.is_solid(),
                                    None => true, // Draw face if neighbor is out of bounds
                                };

                                if should_draw_face {
                                    // Add vertices for this face
                                    let base_idx = vertex_count;

                                    for &(vx, vy, vz) in &face_vertices[face_idx] {
                                        vertices.push(world_x as f32 + vx);
                                        vertices.push(world_y as f32 + vy);
                                        vertices.push(world_z as f32 + vz);

                                        normals.push(face_normals[face_idx].0);
                                        normals.push(face_normals[face_idx].1);
                                        normals.push(face_normals[face_idx].2);

                                        // Blue color for blocks
                                        colors.push(100);
                                        colors.push(100);
                                        colors.push(255);
                                        colors.push(255);
                                    }

                                    // Add indices for two triangles
                                    indices.push(base_idx);
                                    indices.push(base_idx + 1);
                                    indices.push(base_idx + 2);

                                    indices.push(base_idx);
                                    indices.push(base_idx + 2);
                                    indices.push(base_idx + 3);

                                    vertex_count += 4;
                                }
                            }
                        }
                    }
                }
            }
        }

        // Create mesh if we have vertices
        if !vertices.is_empty() {
            let mut mesh = Mesh::gen_mesh_custom(rl, thread);

            unsafe {
                mesh.upload_mesh_vertex_data(vertices.as_slice());
                mesh.upload_mesh_normal_data(normals.as_slice());
                mesh.upload_mesh_color_data(colors.as_slice());
                mesh.upload_mesh_index_data(indices.as_slice());
            }

            self.mesh = Some(mesh);
        }
    }

    pub fn draw(&self, d: &mut RaylibMode3D<RaylibDrawHandle>)
    {
        if let Some(ref mesh) = self.mesh {
            d.draw_mesh(
                mesh,
                Material::default(),
                Matrix::identity(),
            );
        }
        d.draw_grid(50, 1.0);
    }
}


--- ./src/level/utils.rs ---
use raylib::prelude::*;

pub const CHUNKSIZE: usize = 32;
pub const WORLDHEIGHT: usize = 64;
pub const WORLDSIZE_CHUNK: usize = 4;
pub const WORLDSIZE_BLOCKS: usize = WORLDSIZE_CHUNK * CHUNKSIZE;

#[derive(Copy, Clone)]
pub struct IntVec3
{
    pub x: i32,
    pub y: i32,
    pub z: i32,
}

impl IntVec3
{
    pub fn toRLVec3(self) -> Vector3
    {
        return Vector3 {
            x: self.x as f32,
            y: self.y as f32,
            z: self.z as f32,
        };
    }

    pub fn zero() -> Self
    {
        Self {
            x: 0, y: 0, z: 0
        }
    }
}

#[derive(Copy, Clone)]
pub struct ChunkLoc
{
    pub loc: IntVec3,
}

impl ChunkLoc
{
    pub fn toWorldLoc(self) -> IntVec3
    {
        let chunk_size = CHUNKSIZE as i32;
        return IntVec3 {
            x: self.loc.x * chunk_size,
            y: self.loc.y * chunk_size,
            z: self.loc.z * chunk_size,  // Fixed: was using self.loc.x
        };
    }
}


--- ./src/main.rs ---
mod display;
mod level;

fn main()
{
    let mut display = display::Display::new();

    let mut lvl = level::Level::new();
    lvl.terrain.perlinify();

    // Build the mesh after terrain generation
    lvl.terrain.build_mesh(&mut display.rl, &display.thread);

    while !display.rl.window_should_close() {
        {
            lvl.update();
            display.draw_loop(&lvl);
        }
    }
}


